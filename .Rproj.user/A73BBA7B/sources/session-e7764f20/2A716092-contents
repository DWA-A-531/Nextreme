---
title: "Einfuehrung zu Nextreme"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Einfuehrung zu Nextreme}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  fig.width = 6,
  fig.height = 6,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Nextreme)
```

# Einführung
In diesem Beispiel werden praktische Übungen in R gezeigt, wie das Nextreme-Paket, welches die Inhalte des Arbeitsblattes  DWA-A 531 umsetzt,  verwendet werden kann. Es werden im Beispiel die 5-minütigen Niederschlagsdaten der Wetterstation Görlitz verwendet, die frei im Climate Data Center (CDC) des Deutschen Wetterdienstes (DWD) verfügbar sind.
Ein Überblick über die enthaltenen Ziele und Schritte ist im Folgenden aufgeführt:
1.	Herunterladen und Einlesen der 5-min-Niederschlagsdaten aus dem CDC des DWD.
2.	Extremwertanalyse für Niederschlagsdauern von 5 Minuten bis 7 Tagen durchführen.
3.	Vergleich der lokalen Extremwertstatistiken mit der KOSTRA-DWD-2020-Schätzung.


# Benötigte Software

Zunächst ist es erforderlich, [R](https://www.r-project.org) auf dem Rechner zu installieren. Es ist empfohlen, auch [R Studio](https://www.rstudio.com) zu installieren. Das ist eine Programmierumgebung (IDE), die das Arbeiten mit R erleichtert. Ein Tutorial zur Installation beider Programme (für alle gängigen Betriebssysteme) stehen hier [hier](https://www.datacamp.com/community/tutorials/installing-R-windows-mac-ubuntu) zu Verfügung. Nach der Installation der beiden Programme ein neues R-Skript öffnen (File \> New File \> R Script). In diesem Dokument (praktisch eine Textdatei) wird nun nach und nach Programmiercode hinzugefügt, um die Ergebnisse der lokalen Extremwertanalyse, die für die Station Görlitz durchgeführt wurde, zu analysieren und grafisch darzustellen. Die angegebenen Codebeispiele können in das geöffnete R-Skript eingefügt und gespeichert werden.

Als nächstes ist es erforderlich, dass für das Arbeitsblatt DWA-A 531 entwickelte R-Paket „Nextreme“ zu installieren und einzubinden. Das Paket kann aus der bereitgestellten Archiv-Datei (Nextrem.zip) mit folgenden Schritten installiert werden: Tools \> Install Packages \> Install from: Package Archieve File (.zip; .tar.gz) \> Browse to the package location \> Install.

Um die notwendigen Pakete in R-Studio zu laden, verwenden Sie den folgenden Befehl:
```{r}
library("lubridate")
library("rdwd")
library("terra")
library("Nextreme")
```

# Anwendungsbeispiele

## Herunterladen und Einlesen der 5-min-Niederschlagsdaten aus dem CDC des DWD

Das Ziel dieses Beispiels ist es, die 5-Minuten-Zeitreihen der Station Görlitz aus dem Datenportal [CDC](https://opendata.dwd.de/climate_environment/CDC/) des Deutschen Wetterdienstes (DWD) für alle verfügbaren Jahre herunterzuladen und zu lesen.

Eine Liste aller verfügbaren Stationen des DWD ist online [hier](https://opendata.dwd.de/climate_environment/CDC/observations_germany/climate/5_minutes/precipitation/now/) verfügbar. In dieser Liste sind die ID und die Koordinaten der Station Görlitz zu finden. Diese Informationen werden mit folgendem Code in R geladen:

```{r}
Station = data.frame(Stations_id = 01684, geoBreite = 51.1621, geoLaenge = 14.9506)
```

Zunächst werden alle verfügbaren Stationslinks im CDC-Datenportal identifiziert:

```{r}
DWD_5min_precip_links = selectDWD(res="5_minutes", var="precipitation", per="historical")
print(head(DWD_5min_precip_links)) 
```

Es werden nur die Links ausgewählt, die der Stations-ID von Görlitz entsprechen:

```{r}
filename_5min   = paste0("5minutenwerte_nieder_", formatC(Station$Stations_id, flag=0, width=5), "_")
Goerlitz_Indexe = which(grepl(filename_5min, DWD_5min_precip_links)==T)
Goerlitz_Links  = DWD_5min_precip_links[Goerlitz_Indexe]
print(head(Goerlitz_Links))# alle verfügbaren Links für 5min-Niederschlagsdaten in Goerlitz werden angezeigt
```

Anhand der Links lässt sich das Anfangs- und Enddatum der 5-Minuten-Zeitreihe ermitteln:

```{r}
Startdatum   = strsplit(strsplit(Goerlitz_Links[1], split="/")[[1]][[12]], split="_")[[1]][4]
Startdatum   = as.POSIXct(Startdatum, "%Y%m%d", tz="UTC")
print(Startdatum)
Enddatum     = strsplit(strsplit(tail(Goerlitz_Links,1), split="/")[[1]][[12]], split="_")[[1]][5]
Enddatum     = as.POSIXct(Enddatum, "%Y%m%d", tz="UTC")
print(Enddatum)
ges.Periode  = seq(Startdatum, Enddatum, by= 5*60)
```

Erstellung eines leeren Dataframe mit 5-Minuten-Zeitschritten, in den die aufgezeichnete Niederschlagsintensität eingefügt werden soll.

```{r}
Goerlitz_Daten = data.frame(Datum=ges.Periode, RH=NA)
```

Die Niederschlagsdaten aus den DWD-Links in einen Datenframe einlesen.

```{r}
# Den Zielpfad angeben, in den die 5-Minuten-Daten heruntergeladen werden sollen
Zielpfad      = "D:\\DWD5min\\" 
Goerlitz_DWD  = dataDWD(Goerlitz_Links, joinbf=FALSE, read=TRUE, dir=Zielpfad, tz="UTC")
Goerlitz_DWD  = do.call(rbind, Goerlitz_DWD)
rownames(Goerlitz_DWD) = NULL # um lange Link-Namen als Zeilennamen zu vermeiden
```

Die Datumsangaben des DWD-Datenframes (*Goerlitz_DWD*) sollten auf fehlende Zeitschritte überprüft werden. Dazu werden die Zeitwerte im DWD-Datenframe (*Goerlitz_DWD*) mit der 5-Minuten-Sequenz verglichen, die aus dem Start- und dem Enddatum generiert wurde (*Goerlitz_DWD*).

```{r}
# die Bedingung prüfen, ob beide gleich sind
# Wenn False, fehlen Zeitschritte im DWD-Dataframe *Goerlitz_DWD*
# Wenn True, gibt es keine fehlenden Zeitschritte im DWD-Dataframe *Goerlitz_DWD*
print(length(which(Goerlitz_Daten$Datum%in%Goerlitz_DWD$MESS_DATUM)) == length(which( Goerlitz_DWD$MESS_DATUM %in%Goerlitz_Daten$Datum)))
```

Da die Datumseingaben in den beiden Dataframes nicht identisch sind, muss in einem nächsten Schritt geprüft werden, warum dies der Fall ist. Eine erste Prüfung wäre, ob doppelte Datumsangaben in den DWD-Daten vorhanden sind.

```{r}
# Duplikate beim Einlesen von DWD-Daten finden
doppelte.Datum  = Goerlitz_DWD$MESS_DATUM[which(duplicated(Goerlitz_DWD$MESS_DATUM)==T)]
doppelte.Indexe = which(Goerlitz_DWD$MESS_DATUM == doppelte.Datum)
# Duplikate beim Einlesen von DWD-Daten finden
print(Goerlitz_DWD[(doppelte.Indexe[1]-5): (doppelte.Indexe[1] +5),])
print(Goerlitz_DWD[(doppelte.Indexe[2]-5): (doppelte.Indexe[2] +5),])
```

Da der erste duplizierte Eintrag falsch ist, kann er aus dem Dataframe entfernt werden. Dann lässt sich prüfen, ob die Differenz zwischen den einzelnen Datumsangaben gleich 5 Minuten ist (d. h. die Zeitreihe ist komplett belegt, wenn *True* zurückgegeben wird, und hat fehlende Zeitschritte, wenn *False* zurückgegeben wird).

```{r}
Goerlitz_DWD = Goerlitz_DWD[-doppelte.Indexe[1],]
print(all(unique(diff(Goerlitz_DWD$MESS_DATUM))==5)==T)
```

Die Regenhöhe in der Datei sind in drei Spalten (*RWH_05*, *RTH_05* und *RS_05*) auf der Grundlage der verschiedenen verwendeten Sensoren angegeben. Die Niederschlagssumme wird pro Jahr und Sensor berechnet, um die verfügbaren Zeiträume pro Sensor zu unterscheiden und eine klare Vorstellung davon zu bekommen, welche Daten zu verwenden sind.

```{r}
RTH_05Volumen = sapply(1993:2020, function(y) sum(Goerlitz_DWD$RTH_05[which(year(Goerlitz_DWD$MESS_DATUM)==y)], na.rm=T))
print(RTH_05Volumen)
RWH_05Volumen = sapply(1993:2020, function(y) sum(Goerlitz_DWD$RWH_05[which(year(Goerlitz_DWD$MESS_DATUM)==y)], na.rm=T))
print(RWH_05Volumen)
RS_05Volumen  = sapply(1993:2020, function(y) sum(Goerlitz_DWD$RS_05[which(year(Goerlitz_DWD$MESS_DATUM)==y)], na.rm=T))
print(RS_05Volumen)
```

Wie aus der jährlichen Regenmenge erkennbar ist, lassen sich zwei Perioden unterscheiden: die erste Periode, in der die Sensoren RTH (Tropfer) und RWH(Wippe) messen, und die zweite, in der der RS-Sensor misst. Da die jährliche Regenmenge für den RTH-Sensor sehr hoch ist (mehr als 9000 mm), wird die Spalte *RWH_05* für die erste Periode und die Spalte *RS_05* für die zweite Periode verwendet. Außerdem, da im DWD-Datenframe *Goerlitz_DWD* bestimmte Zeitpunkte fehlen, kann der Datenframe *Goerlitz_Daten* nur mit den Zeitpunkten gefüllt werden, die im DWD-Datenframe *Goerlitz_DWD* vorhanden sind.

```{r}
erstePeriode = Goerlitz_DWD[which(is.na(Goerlitz_DWD$RWH_05)==F),]
print(range(erstePeriode$MESS_DATUM))
zweitePeriode = Goerlitz_DWD[which(is.na(Goerlitz_DWD$RS_05)==F),]
print(range(zweitePeriode$MESS_DATUM))
Goerlitz_Daten[which(Goerlitz_Daten$Datum%in%erstePeriode$MESS_DATUM),2]  = erstePeriode$RWH_05[which( erstePeriode$MESS_DATUM %in%Goerlitz_Daten$Datum)]
Goerlitz_Daten[which(Goerlitz_Daten$Datum%in%zweitePeriode$MESS_DATUM),2] = zweitePeriode$RS_05[which( zweitePeriode$MESS_DATUM %in%Goerlitz_Daten$Datum)]
print(head(Goerlitz_Daten))
Sensor_WechselZeit = range(zweitePeriode$MESS_DATUM)[1]
```

Der Datenframe ist vollständig mit Datum und Regenintensitäten in mm pro 5 Minuten. Für fehlende Werte wird der Fehlwert "NA" verwendet. Der nächste Code prüft für jedes Jahr die jährliche Niederschlagssumme, die maximale Intensität (mm/5min) und die Länge der nicht fehlenden Werte.

```{r}
summary(Goerlitz_Daten$RH[which(Goerlitz_Daten>0)])
jaehrlicheVolum = sapply(1993:2020, function(y) sum(Goerlitz_Daten$RH[which(year(Goerlitz_Daten$Datum)==y)], na.rm=T))
print(jaehrlicheVolum)
jaehrliche.MaxInt = sapply(1993:2020, function(y) max(Goerlitz_Daten$RH[which(year(Goerlitz_Daten$Datum)==y)], na.rm=T))
print(jaehrliche.MaxInt)
jaehrliche.Beobachtungen  = sapply(1993:2020, function(y) length(which(is.na(Goerlitz_Daten$RH[which(year(Goerlitz_Daten$Datum)==y)])==F)))
print(jaehrliche.Beobachtungen)
```

Die extrahierte 5-minütige Regenserie erscheint plausibel und wird daher im nächsten Schritt für die Extremwertanalyse verwendet.


## Extremwertanalyse für Dauern von 5 Minuten bis 7 Tagen durchführen.

Für die extrahierten 5-Minuten-Niederschlagsreihen in Görlitz wird eine lokale Extremwertanalyse gemäß den im Arbeitsblatt DWA-A 531 beschriebenen Schritten durchgeführt, die darin bestehen:

1. Berechnung der maximalen jährlichen Niederschlagsintensitäten, die bei bestimmten Dauern (hier 5, 10, 15, 30, 60, 120, 360, 720, 1440, 2880, 4320, 10080 Minuten) beobachtet wurden.

2. Da die Niederschlagsreihe in 5-Minuten-Blöcken verfügbar ist, wird die jährliche Maximalintensitäten für die Dauern von 5, 10, 15 und 20 Minuten korrigiert (Intervallkorrektur, siehe Tabelle 1 in DWA-A 531).

3. Da der Sensortyp an der Station Görlitz sich über die Zeit ändert, wird überprüft, ob die jährlichen Maximalreihen der kurzen Dauern (5, 10, 15 und 30 Minuten) eine sprunghafte Instationarität aufweisen, die dem Datum des Sensorwechsels entspricht. Wenn es eine solche sprunghafte Instationarität gibt, wird der Sprung eliminiert.

------------------------------------------------------------------------
**HINWEIS: Dieser Schritt wird hier nur durchgeführt, um ein Beispiel für eine solche Anwendung zu zeigen. Laut Arbeitsblatt DWA-A 531 sollte eine Sprungkorrektur getestet werden, wenn ein Sensor vom analogen (Regenschreiber) zum digitalen Typ gewechselt wurde. An der Station Görlitz sind in diesem Beispiel alle Sensoren digital, so dass eine Sprungprüfung und -korrektur eigentlich nicht erforderlich wäre. Hier wird dieser Schritt nur gezeigt, um einen vollständigen Arbeitsablauf darzulegen!**
------------------------------------------------------------------------

4. Anpassung der Generalisierten Extremwert Verteilung (GEV) an die erhaltenen jährlichen Serien der maximalen Niederschlagsintensität für die Station Görlitz. Die Koutsoyiannis-Methode, wie auf den Arbeitsblatt DWA-A 531 beschrieben, wird zur Normalisierung der Intensitäten über die gegebenen Dauerstufen verwendet.

5.	Berechnung der Jährlichkeit (Wiederkehrintervalle) der beobachteten Regenhöhe und bestimmten Dauerstufen auf der Grundlage der berechneten Extremwertparameter.

6.	Durchführung eines Bootstrapps, um die Unsicherheit der Stichprobe bei der Anpassung der Extremwertparameter an die Serie der Station Görlitz zu berücksichtigen.


### Ableitung der jährlichen maximalen Regenintensitäten aus der 5-min-Zeitreihe.

Zunächst werden die maximalen jährlichen Niederschlagsintensitäten bei bestimmten Dauern (5, 10, 15, 30, 60, 120, 360, 720, 1440, 2880, 4320, 10080 Minuten) berechnet.

Zu diesem Zweck kann die Funktion *jaehrliche_maxSerie()* verwendet werden. Hier wird eine Dauer (*DSDmin*) von 4 Stunden verwendet, um unabhängige Regenereignisse zu trennen, und da die Regendaten in 5-Minuten-Zeitschritten gegeben sind, wird das Intervallargument (*Intervall*) auf 5 gesetzt. Um die Parameter der Extremwertverteilung zu ermitteln, sind die maximalen jährlichen Niederschlagsintensitäten für jede Dauer erforderlich. Aus diesem Grund geben wir *SerieTyp=„INT“* an, um die maximalen Intensitäten als Ausgabe zu erhalten.

```{r}
Goerlitz_maxSerie = jaehrliche_maxSerie(Goerlitz_Daten, Dauern = c(5, 10, 15, 30, 60, 120, 360, 720, 1440, 2880, 4320, 10080), DSDmin=240, Intervall = 5, SerieTyp = "INT")
print(Goerlitz_maxSerie)
```

Die Variable *Goerlitz_maxSerie* ist eine Tabelle mit der maximalen Intensität (mm/h), die bei verschiedenen Dauern (in Spalten) und Jahren (in Zeilen) ermittelt wurde.

Anschließend wird eine Korrektur der berechneten jährlichen Serien für Dauern, kleiner oder gleich dem 4-fachen des Grundintervalls, vorgenommen. Zu diesem Zweck kann die Funktion *Intervallkorrektur()* verwendet werden. Da die Regendaten in 5-Minuten-Zeitschritten gegeben sind, wird das Intervallargument (*Intervall*) auf 5 gesetzt und damit Dauerstufen bis 20 min bei der Korrektur berücksichtigt.

```{r}
Goerlitz_maxSerie    = Intervallkorrektur(Goerlitz_maxSerie, Intervall = 5)
```

Schließlich wird eine Sprungeliminierung bei Dauern bis 30 Minuten durchgeführt, falls eine sprunghafte Instationarität in den jährlichen Serien vorhanden ist. Zu diesem Zweck kann die Funktion *Sprung_Korrektur()* verwendet werden. Zusätzlich zur Eingabe der jährlichen Serie (*Goerlitz_maxSerie*) benötigt die Funktion das Datum des Sensorwechsels in einer Variablen vom Typ *Date*.

```{r}
WechselDatum = as.Date(Sensor_WechselZeit)
Goerlitz_maxSerie_korrigiert    = Sprung_Korrektur(Goerlitz_maxSerie, WechselDatum)
# Die Differenz vor und nach der Funktion sprungKorrektur() überprüfen.
print(round(Goerlitz_maxSerie_korrigiert-Goerlitz_maxSerie,0))
```

Wie bereits erwähnt, gibt es in diesem Beispiel keine Sprünge in den Daten, und daher ist die von der Funktion *Sprung_Korrektur()* zurückgegebene Tabelle dieselbe wie die Eingabe.

### Schätzung der Parameter, die die Verteilung der Extremwerte über alle Dauern beschreiben

Die Funktion *Parameter_Schaetzung* kann verwendet werden, um die Extremwertparameter aus den erhaltenen jährlichen Maximalintensitätsreihen zu schätzen. In der Funktion sollte die Dauer für die Extremwertparameter angegeben werden, und die Art der Verteilung, die angepasst werden soll. Wie in Arbeitsblatt DWA-A 531 wird hier die GEV-Verteilung mit einem festen Formparameter von -0,1 (Fréchet-Typ) verwendet. Ddeshalb lauten die Argumente *methGEV="GEV ‚*, *formTyp=‘FIX “* und *Gamma=-0,1*.

------------------------------------------------------------------------
**HINWEIS: Die Funktion *Parameter_Schaetzung()* kann entweder eine GEV oder eine Gumbel-Verteilung (Formparameter = 0.0) anpassen Für die Gumbel-Verteilung (*methGEV=“GUM”*)  bleiben *formTyp* und *Gamma* unberücksichtigt; für die GEV kann der Formparameter hingegen auch frei aus L-Momenten geschätzt werden (mit *formTyp=“CON”*, in diesem Fall wird *Gamma* nicht berücksichtigt). In allen Fällen werden die maximalen Intensitäten über die gegebene Dauerstufe normalisiert. Die Funktion *Parameter_Schaetzung()* kann nicht GEV-Verteilungen individuell an jede Dauer anpassen!**
------------------------------------------------------------------------

------------------------------------------------------------------------
**WICHTIG: Die Funktion *Parameter_Schaetzung()* funktioniert nur, wenn die jährlichen Maximalreihen Niederschlagsintensitäten (mm/h) und NICHT Niederschlagsvolumen (mm/Dauer) sind!**
------------------------------------------------------------------------
```{r}
N_pars      = Parameter_Schaetzung(Goerlitz_maxSerie, Dauern = c(5, 10, 15, 30, 60, 120, 360, 720, 1440, 2880, 4320, 10080), methGEV="GEV", formTyp = "FIX", Gamma = -0.1)
print(N_pars)
```

Die zurückgegebene Variable *N_pars* ist ein einzeiliger Dataframe, der die berechneten Parameter der Extremwertverteilung des Niederschlags an der Station Goerliz enthält: *Mu* - der GEV- Lokationsparameter, *Sigma* - der GEV- Skalenparameter, *Gamma* - der GEV- Formparameter, *Theta* und *Eta* jeweils der erste und zweite Koutsoyiannis- Parameter, während *KW* die Kruskal-Wallis Teststatistik ist, die bei der Optimierung der Parameter erreicht wurde.

### Schätzung der Regenhöhe für angegeben Regendauer und Wiederkehrintervalle

Sobald die Parameter bekannt sind, lässt sich die zu erwartende Regenhöhe bei verschiedenen Dauern und Wiederkehrintervalle an der Station Görlitz berechnen. Zu diesem Zweck kann die Funktion *hN_Schaetzung()* verwendet werden. Neben den Parametern (*N_pars*), den Dauern (*Dauern*) und Wiederkehrintervalle (*Tn*), sollte auch die GEV-Methode (*methGEV*) angegeben werden. In diesem Fall wird der *SerieTyp* auf *VOL* gesetzt, um Regenhöhe (mm/Dauer) als Output zu erhalten. Außerdem kann die Art der Ausgabe mit dem Argument *SerieTyp* gesteuert werden (*VOL* für Regenhöhe in mm/Dauer oder *INT* für Regenintensität in mm/h).

```{r}
H_quas      = hN_Schaetzung(N_pars, Dauern = c(5, 10, 15, 30, 60, 120, 360, 720, 1440, 2880, 4320, 10080),Tn =c(2,5,10,20,50,100), methGEV="GEV",SerieTyp = "VOL")
print(H_quas)
```

Die zurückgegebene Variable *H_quas* ist eine Tabelle (Dataframe-Format) mit den Wiederkehrintervallen in verschiedenen Zeilen und der Regendauer in verschiedenen Spalten. Da in diesem Fall der *SerieTyp=„VOL“* ist, sind die Einheiten in mm/Dauer.

### Schätzung der Unsicherheitsbereiche auf der Grundlage von Stichproben-Bootstrapping
Neben den bisher angegebenen typischen Informationen zur Berechnung von Parametern und Extremwerten können drei weitere Argumente festgelegt werden: *nBoots* - zur Angabe der gewünschten Anzahl von Realisierungen, *rSeed* - eine Zufallszahl, um sicherzustellen, dass die Ausgabe wiederholbar ist, und *Konfidenzgrenzen* - zur Angabe der Quantils der oberen (Ko) und unteren Konfidenzintervallgrenzen (Ku). Die geschätzten jährlichen Maximalintensitätsserien können *nBoots*-mal mit Ersatz neu gesampelt werden, um die Stichprobenunsicherheit zu berücksichtigen. Anschließend können für jede *nBoots*-Realisierung die Parameter geschätzt werden. Auf diese Weise erhält man *nBoots* Realisierungen der Parameter, die als Grundlage für die Berechnung von Konfidenzintervallen nicht nur der Parameter, sondern auch der Quantile verwendet werden können. 
Zu diesem Zweck kann die Funktion *Unsicherheit_Schaetzung()* implementiert werden. 
**Hinweis: Dies kann mehrere Minuten dauern!**

```{r}
KI          = Unsicherheit_Schaetzung(Goerlitz_maxSerie,
                                  Tn =c(2,5,10,20,50,100),
                                  Dauern = c(5, 10, 15, 30, 60, 120, 360, 720, 1440, 2880, 4320, 10080),
                                  methGEV="GEV",
                                  formTyp = "FIX",
                                  Gamma=-0.1,
                                  nBoots = 100,
                                  rSeed = 1232,
                                  SerieTyp = "VOL",
                                  Konfidenzgrenzen  = c(0.025,0.975))
# Zugriff auf die Parameterinformationen
PAR_KI      = KI$PAR_INFO
# Zugriff auf die Quantils Informationen 
HN_KI       = KI$QUA_INFO
```

Die Funktion *Unsicherheit_Schaetzung()* gibt eine Liste mit den Parameterinformationen *PAR_INFO* und Quantils Informationen *QUA_INFO* zurück. Die beiden Einträge in der Liste enthalten Informationen über die angegebenen Quantile für die Berechnung der Grenzen des Konfidenzintervalls, des Mittelwerts der Realisierungen und der relativen Unsicherheit *(Ko-Ku)/K*. 

### Darstellung der lokal geschätzten Regenhöhen unter Berücksichtigung des Unsicherheitsbereichs
Der folgende Code zeigt ein Beispiel für die Visualisierung verschiedener Regenhöhen an der Station Görlitz, die mit verschiedenen Dauerstufen (auf der x-Achse) und Wiederkehrintervallen (in verschiedenen Farben) einhergehen. Für beide Achsen wird eine logarithmische Darstellung verwendet. 

```{r, echo=TRUE, eval=TRUE, include=TRUE}
Dauern = c(5, 10, 15, 30, 60, 120, 360, 720, 1440, 2880, 4320, 10080)
Tn_Farbe    = rev(hcl.colors(6, palette = "viridis"))
plot(Dauern, H_quas["2",], type="l", lwd=2, lty=1, log="xy", col=Tn_Farbe[1], ylab="hN [mm]", ylim=range(H_quas), xlab="Dauer [min]", main = "Station 01684")
lines(Dauern, H_quas["5",],  lwd=2, col=Tn_Farbe[2])
lines(Dauern, H_quas["10",], lwd=2, col=Tn_Farbe[3])
lines(Dauern, H_quas["20",], lwd=2, col=Tn_Farbe[4])
lines(Dauern, H_quas["50",], lwd=2, col=Tn_Farbe[5])
lines(Dauern, H_quas["100",],lwd=2, col=Tn_Farbe[6])
legend("bottomright", legend = c(2,5,10,20,50,100),lty=1, lwd=3, col=Tn_Farbe, cex=0.8, title="Tn", horiz=T, bty="n")
```

Im folgenden Beispiel wird ein Code-Teil zur Darstellung des 100-jährlichen Regenvolumens für die Station Görlitz gegeben, wie es für die Dauer von 5 Minuten bis 7 Tagen aus der bisher durchgeführten Extremwertanalyse der 5-Minuten-Niederschlagsdaten des DWD berechnet wurde (in rot dargestellt). Die Konfidenzgrenze, die den 2.5 %- und 97.5 %-Quantils der 100 Realisierungen für die 100-jährliche Regenmenge entsprechen, sind ebenfalls in blau dargestellt.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
Dauern = c(5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080)
plot(Dauern, H_quas["100",], type="l", lwd=2, lty=2, log="xy", ylim=range(HN_KI$`97.5%`["100",], HN_KI$`2.5%`["100",]), col="red",
     ylab="hN [mm]", xlab="Dauer [min]", main = "Station 01684")
polygon(c(Dauern, rev(Dauern)), c(HN_KI$`2.5%`["100",], rev(HN_KI$`97.5%`["100",])), col="royalblue", border=NA)
lines(Dauern, HN_KI$Mittelwert["100",], type="l", col="royalblue4", lwd=2)
lines(Dauern, H_quas["100",], type="l", col="red", lwd=2, lty=2)
legend("topleft", c("95%KI", "Mittelwert", "lokale Schätzung"),  col=c("royalblue", "royalblue4", "red"), lty=c(1, 1, 2), lwd=c(10,2,2), title = "Legende", bty="n")
```

Der folgende Code zeigt drei verschiedene Beispiele für die Visualisierung der berechneten relativen Unsicherheiten (Ko-Ku/K) aus dem *nBoots* Bootstrapping als eine Möglichkeit, die Unsicherheit zu messen.Die Einheiten sind in Prozent ausgegeben.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
KI = round(HN_KI$rel.Unsicherheit,2)
# Option 1 
barplot(as.matrix(KI), col=Tn_Farbe, ylab="KI [%]",  xlab="Dauer [min]", main = "Station 01684")
legend("top", legend = c(2,5,10,20,50,100), fill=Tn_Farbe, cex=0.8, title="Tn", horiz=T, bty="n")
# Option 2 
barplot(as.matrix(KI),col=Tn_Farbe, beside=T, ylim=c(0,50), ylab="KI [%]", xlab="Dauer [min]", main = "Station 01684")
legend("top", legend = c(2,5,10,20,50,100), fill=Tn_Farbe, cex=0.8, title="Tn", horiz=T, bty="n")
# Option 3 
Dauer_Farbe = hcl.colors(dim(KI)[2], "blues", rev = T)
barplot(as.matrix(t(KI)),col=Dauer_Farbe, beside=T, ylim=c(0,60), ylab="KI [%]", xlab="Tn", main = "Station 01684")
legend("top", legend = Dauern, fill=Dauer_Farbe, cex=0.8, title="Dauer (min)",  bty="n", ncol=6)

```

### Schätzung der Wiederkehrintervalle auf der Grundlage der beobachteten Werte eines Regenereignisses

Möglicherweise ist es auch erwünscht, dass nach der Beobachtung eines Regenereignisses die Jährlichkeit bei verschiedenen Dauern erfasst werden kann. Zu diesem Zweck kann die Funktion *Tn_Schaetzung* verwendet werden. Die Parameter *N_pars*, die die Extremwertstatistik beschreiben, sollten als einzeiliger Dataframe angegeben (Benennung der Spalten ist wichtig!), die beobachtete Regenmenge *hN* in mm sollten bei verschiedenen Dauern *Dauern* als Vektor angegeben. Es ist wichtig, dass die Länge der Vektoren *hN* und *Dauern* übereinstimmen! Außerdem sollte es in der Funktion angegeben ob die Gumbel- oder GEV-Parameter in N_pars verwendet sind. 

```{r, echo=TRUE, eval=TRUE, include=TRUE}
Hn_Tn        = Tn_Schaetzung(N_pars,Dauern = c(5, 10, 60), 
                            hN   = c(15, 20, 30),
                            methGEV="GEV")
print(Hn_Tn)

```

Die Funktion *Tn_Schaetzung()* liefert eine Tabelle mit der beobachteten Regenhöhe (mm), der Regendauer (min) und der geschätzten Wiederkehrintervalle (Tn).

## Vergleich mit den KOSTRA-DWD-2020 Schätzungen
Für einen bestimmten Ort ist es auch möglich, die örtlich geschätzte Statistik mit den Bemessungsniederschlägen nach KOSTRA-DWD-2020 zu vergleichen. In den folgenden Beispielen wird gezeigt, wie die Informationen über Extremniederschläge aus den KOSTRA-DWD-2020-Datensatz extrahiert und mit den bisher berechneten Informationen verglichen werden können.

------------------------------------------------------------------------
**Hinweis: Das Beispiel wird hier nur für eine Station - Görlitz - gezeigt. Es ist jedoch möglich, mehrere Stationen auf einmal zu berechnen. Weitere Informationen finden Sie in der Funktion *help(Kostra2020_hN_Schaetzung)* oder *help(Kostra2020_Parameter)*.**
------------------------------------------------------------------------

Die Funktion *Kostra2020_hN_Schaetzung()* liest für bestimmte Standortkoordinaten, Dauer und Wiederkehrintervalle die entsprechende extreme Regenhöhe (*hN*) und den Unsicherheitsbereich (wenn Argument *Unsicherheit=T*). Das folgende Beispiel liest die KOSTRA-DWD-2020 Regenhöhe für Görlitz und die angegebenen Dauern und Wiederkehrintervalle.

```{r}
Tn = c(2,5,10,20,50,100)
Dauern = c(5, 10, 15, 30, 60, 120, 360, 720, 1440, 2880, 4320, 10080)
Station = data.frame(Stations_id = 01684, geoBreite = 51.1621, geoLaenge = 14.9506)
H_quas_Kostra = Kostra2020_hN_Schaetzung(Standorte = Station, Dauern=Dauern, Tn =Tn, Temp_Pfad = "./", Unsicherheit=T)
# Zugang zu den Regenhöhen und formatiert sie so, dass sie der zuvor geschätzten Tabelle H_quas entsprechen. 
Hn_Kostra = H_quas_Kostra$Kostra_HN
print(Hn_Kostra)
Hn_Kostra = matrix(unlist(Hn_Kostra[1,-(1:3)]), nrow = 6, ncol = 12, byrow=F) 
Hn_Kostra = as.data.frame(Hn_Kostra)
rownames(Hn_Kostra) = Tn
names(Hn_Kostra) = Dauern

# Zugang zu den Unsicherheiten und formatiert sie so, dass sie der zuvor geschätzten Tabelle H_quas entsprechen. 
UC_Kostra = H_quas_Kostra$Kostra_UC
print(UC_Kostra)
UC_Kostra = matrix(unlist(UC_Kostra[1,-(1:3)]), nrow = 6, ncol = 12, byrow=F) 
UC_Kostra = as.data.frame(UC_Kostra)
rownames(UC_Kostra) = Tn
names(UC_Kostra) = Dauern

# Da die KOSTRA-DWD-2020 Unsicherheiten in Prozent angegeben sind, kann die obere und untere Konfidenzgrenze wie folgt berechnet werden:
Hn_Kostra_Ku =  Hn_Kostra - round(UC_Kostra*Hn_Kostra/100,2) # untere Grenze
Hn_Kostra_Ko =  Hn_Kostra + round(UC_Kostra*Hn_Kostra/100,2) # obere Grenze
```

Das folgende Beispiel zeigt einen Codeausschnitt zur Darstellung der 100-jährlichen Regenhöhen für die Station Görlitz, wie es für die Dauern von 5 Minuten bis 7 Tagen aus der bisher durchgeführten Extremwertanalyse der 5-Minuten-Niederschlagsdaten des DWD (rot dargestellt) und KOSTRA-DWD-2020 (schwarz dargestellt) berechnet wurde. Die 95% Konfidenzgrenzen von KOSTRA-DWD-2020 und der lokalen Analyse sind ebenfalls grau bzw. blau dargestellt.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
Dauern = c(5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080)
plot(Dauern, H_quas["100",], type="l", lwd=2, lty=2, log="xy", ylim=range(HN_KI$`97.5%`["100",], HN_KI$`2.5%`["100",], Hn_Kostra_Ku["100",], Hn_Kostra_Ko["100",]), col="red",
     ylab="hN [mm]", xlab="Dauer [min]", main = "Station 01684, Tn=100")
polygon(c(Dauern, rev(Dauern)), c(Hn_Kostra_Ku["100",], rev(Hn_Kostra_Ko["100",])), col="lightgrey", border=NA)
polygon(c(Dauern, rev(Dauern)), c(HN_KI$`2.5%`["100",], rev(HN_KI$`97.5%`["100",])), col="royalblue", border=NA)
lines(Dauern, HN_KI$Mittelwert["100",], type="l", col="royalblue4", lwd=2)
lines(Dauern, H_quas["100",], type="l", col="red", lwd=2, lty=2)
lines(Dauern, Hn_Kostra["100",], type="l", col="black", lwd=2, lty=2)

legend("topleft", c("lokale - 95%KI", "lokale Mittelwert", "lokale Hn", "Unsicherheitbereich KOSTRA-DWD-2020",  "KOSTRA-DWD-2020"),  col=c("royalblue", "royalblue4", "red", "lightgrey", "black"), lty=c(1, 1, 2, 1, 2), lwd=c(10,2,2, 10, 2), title = "Legende", bty="n")
```

Das folgende Beispiel zeigt einen Codeausschnitt zur Darstellung der Regenhöhen mit D=60min für die Station Görlitz, wie es für die Wiederkehrintervalle von 2 bis 100 Jahren aus der bisher durchgeführten Extremwertanalyse der 5-Minuten-Niederschlagsdaten des DWD (rot dargestellt) und KOSTRA-DWD-2020 (schwarz dargestellt) berechnet wurde. Die 95% Konfidenzgrenzen von KOSTRA-DWD-2020 und der lokalen Analyse sind ebenfalls grau bzw. blau dargestellt.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
plot(Tn, H_quas[,"60"], type="l", lwd=2, lty=2, log="x", ylim=range(15, 70), col="red",
     ylab="hN [mm]", xlab="Tn", main = "Station 01684, D=60min")
polygon(c(Tn, rev(Tn)), c(Hn_Kostra_Ku[,"60"], rev(Hn_Kostra_Ko[,"60"])), col="lightgrey", border=NA)
polygon(c(Tn, rev(Tn)), c(HN_KI$`2.5%`[,"60"], rev(HN_KI$`97.5%`[,"60"])), col="royalblue", border=NA)
lines(Tn, HN_KI$Mittelwert[,"60"], type="l", col="royalblue4", lwd=2)
lines(Tn, H_quas[,"60"], type="l", col="red", lwd=2, lty=2)
lines(Tn, Hn_Kostra[,"60"], type="l", col="black", lwd=2, lty=2)
legend("topleft", c("lokale - 95%KI", "lokale Mittelwert", "lokale Hn", "Unsicherheitbereich KOSTRA-DWD-2020",  "KOSTRA-DWD-2020"),  col=c("royalblue", "royalblue4", "red", "lightgrey", "black"), lty=c(1, 1, 2, 1, 2), lwd=c(10,2,2, 10, 2), title = "Legende", bty="n")
```

Die Funktion *Kostra2020_Parameter()* liest für bestimmte Standortkoordinaten die entsprechende Parameter von KOSTRA-DWD-2020. Das folgende Beispiel liest die  KOSTRA-DWD-2020 Parameter für Görlitz. Dann wird die *Tn_Schaetzung()* Funktion verwendet um die Jährlichkeit der beobachtete Regenmenge *hN* bei verschiedenen Dauern *Dauern* zu schätzen.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
kostraParameter    = Kostra2020_Parameter(Standorte = Station )
Hn_Tn_Kostra       = Tn_Schaetzung(kostraParameter, Dauern = c(5, 10, 60), 
                            hN   = c(15, 20, 30), # values have to be in mm
                            methGEV="GEV")
print(Hn_Tn_Kostra)

```

