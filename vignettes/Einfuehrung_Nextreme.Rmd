---
title: "Einfuehrung zu Nextreme"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Einfuehrung zu Nextreme}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  fig.width = 6,
  fig.height = 6,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Nextreme)
```

# Einführung

In diesem Beispiel werden praktische Übungen in R gezeigt, wie das Nextreme-Paket (das mit dem DWA-A 531 Merkblatt bereitbestellt wird) verwendet werden kann, um eine statistische Analyse der Niederschlagsextremwerte an der Göritzer Niederschlagsstation des Deutschen Wetterdienstes (DWD) durchzuführen.

Ein Überblick über die enthaltenen Ziele und Schritte ist im Folgenden aufgeführt:

1.  Herunterladen und Einlesen der 5m-Niederschlagsdaten aus dem DWD-Datenportal.

2.  Extremwertanalyse für Niederschlagsdauern von 5 Minuten bis 7 Tagen durchführen.

3.  Vergleich der lokalen Extremwertstatistiken mit der Kostra 2020-Schätzung.

# Benötigte Software

Zunächst ist es erforderlich, [R](https://www.r-project.org) auf dem Rechner zu installieren. Es ist empfohlen, auch [R Studio](https://www.rstudio.com) zu installieren. Das ist eine Programmierumgebung (IDE), die das Arbeiten mit R erleichtert. Ein Tutorial zur Installation beider Programme (für alle gängigen Betriebssysteme) stehen hier [hier](https://www.datacamp.com/community/tutorials/installing-R-windows-mac-ubuntu) zu Verfügung. Nach der Installation der beiden Programme ein neues R-Skript öffnen (File \> New File \> R Script). In diesem Dokument (praktisch eine Textdatei) wird nun nach und nach Programmiercode hinzugefügt, um die Ergebnisse der lokalen Extremwertanalyse, die am Bahnhof Görlitz durchgeführt wurde, zu analysieren und grafisch darzustellen. Die angegebenen Codebeispiele können in das geöffnete R-Skript eingefügt und gespeichert werden.

Als nächstes ist es erforderlich, das für das DWA-A 531 Merkblatt entwickelte R-Paket „Nextreme“ zu installieren und hochzuladen. Das Paket kann aus der bereitgestellten Archiv-Datei (Nextrem.zip) mit folgenden Schritten installiert werden: Tools \> Install Packages \> Install from: Package Archieve File (.zip; .tar.gz) \> Browse to the package location \> Install.

Um die notwendige Pakete in R-Studio zu laden, verwenden Sie den folgenden Befehl:
```{r}
library("lubridate")
library("rdwd")
library("terra")
library("Nextreme")
```

# Anwendungsbeispiele

## Herunterladen und Einlesen der 5m-Niederschlagsdaten aus dem DWD-Datenportal

Das Ziel dieses Beispiels ist es, die 5-Minuten-Zeitreihen der Station Görlitz aus dem Datenportal des Deutschen Wetterdienstes (DWD) [CDC](https://opendata.dwd.de/climate_environment/CDC/) für alle verfügbaren Jahre herunterzuladen und zu lesen.

Eine Liste aller verfügbaren Stationen des DWD ist online verfügbar [5min](https://opendata.dwd.de/climate_environment/CDC/observations_germany/climate/5_minutes/precipitation/now/). In dieser Liste sind die Kennung und die Koordinaten der Goerlitz Station zu finden. Diese Informationen werden mit folgendem Code in R geladen:

```{r}
Station = data.frame(Stations_id = 01684, geoBreite = 51.1621, geoLaenge = 14.9506)
```

Zunächst werden alle verfügbaren Stationslinks im CDC-Datenportal identifiziert:

```{r}
DWD_5min_precip_links = selectDWD(res="5_minutes", var="precipitation", per="historical")
print(head(DWD_5min_precip_links)) # Es werden nur die Links ausgewählt, die der Stations-ID von Goerlitz enthalten:
```

Es werden nur die Links ausgewählt, die der Stations-ID von Görlitz entsprechen:

```{r}
filename_5min   = paste0("5minutenwerte_nieder_", formatC(Station$Stations_id, flag=0, width=5), "_")
Goerlitz_Indexe = which(grepl(filename_5min, DWD_5min_precip_links)==T)
Goerlitz_Links  = DWD_5min_precip_links[Goerlitz_Indexe]
print(head(Goerlitz_Links))# alle verfügbaren Links für 5min-Niederschlagsdaten in Goerlitz werden angezeigt
```

Anhand der Links lässt sich das Anfangs- und Enddatum der 5-Minuten-Zeitreihe ermitteln:

```{r}
Startdatum   = strsplit(strsplit(Goerlitz_Links[1], split="/")[[1]][[12]], split="_")[[1]][4]
Startdatum   = as.POSIXct(Startdatum, "%Y%m%d", tz="UTC")
print(Startdatum)
Enddatum     = strsplit(strsplit(tail(Goerlitz_Links,1), split="/")[[1]][[12]], split="_")[[1]][4]
Enddatum     = as.POSIXct(Enddatum, "%Y%m%d", tz="UTC")
print(Enddatum)
ges.Periode  = seq(Startdatum, Enddatum, by= 5*60)
```

Erstellung eines leeren Dataframe mit 5-Minuten-Zeitschritten, in den die aufgezeichnete Niederschlagsintensität eingefügt werden soll.

```{r}
Goerlitz_Daten = data.frame(Datum=ges.Periode, RH=NA)
```

Die Niederschlagsdaten aus den DWD-Links in einen Datenframe einlesen.

```{r}
Goerlitz_DWD  = dataDWD(Goerlitz_Links, joinbf=FALSE, read=TRUE, tz="UTC")
Goerlitz_DWD  = do.call(rbind, Goerlitz_DWD)
rownames(Goerlitz_DWD) = NULL # um lange Link-Namen als Zeilennamen zu vermeiden
```

Die Datumsangaben des DWD-Datenframes (*Goerlitz_DWD*) sollten auf fehlende Zeitschritte überprüft werden. Dazu werden die Zeitwerte im DWD-Datenframe (*Goerlitz_DWD*) mit der 5-Minuten-Sequenz verglichen, die aus dem Start- und dem Enddatum generiert wurde (*Goerlitz_DWD*).

```{r}
# die Bedingung prüfen, ob beide gleich sind
# Wenn False, fehlen Zeitschritte im DWD-Dataframe *Goerlitz_DWD*
# Wenn True, gibt es keine fehlenden Zeitschritte im DWD-Dataframe *Goerlitz_DWD*
print(length(which(Goerlitz_Daten$Datum%in%Goerlitz_DWD$MESS_DATUM)) == length(which( Goerlitz_DWD$MESS_DATUM %in%Goerlitz_Daten$Datum)))
```

Da die Datumseingaben in den beiden Dataframes nicht identisch sind, muss in einem nächsten Schritt geprüft werden, warum dies der Fall ist. Eine erste Prüfung wäre, ob doppelte Datumsangaben in den DWD-Daten vorhanden sind.

```{r}
# Duplikate beim Einlesen von DWD-Daten finden
doppelte.Datum  = Goerlitz_DWD$MESS_DATUM[which(duplicated(Goerlitz_DWD$MESS_DATUM)==T)]
doppelte.Indexe = which(Goerlitz_DWD$MESS_DATUM == doppelte.Datum)
# Duplikate beim Einlesen von DWD-Daten finden
print(Goerlitz_DWD[(doppelte.Indexe[1]-5): (doppelte.Indexe[1] +5),])
print(Goerlitz_DWD[(doppelte.Indexe[2]-5): (doppelte.Indexe[2] +5),])
```

Da der erste duplizierte Eintrag falsch ist, kann er aus dem Dataframe entfernt werden. Dann lässt sich prüfen, ob die Differenz zwischen den einzelnen Datumsangaben gleich 5 Minuten ist (d. h. die Zeitreihe ist komplett bedeckt , wenn sie *True* ist, und hat fehlende Zeitschritte, wenn sie *False* ist).

```{r}
Goerlitz_DWD = Goerlitz_DWD[-doppelte.Indexe[1],]
print(all(unique(diff(Goerlitz_DWD$MESS_DATUM))==5)==T)
```

Die Regenhöhe von DWD sind in drei Spalten (*RWH_05*, *RTH_05* und *RS_05*) auf der Grundlage der verschiedenen verwendeten Sensoren angegeben. Die Niederschlagsvolum wird pro Jahr und Sensor berechnet, um die verfügbaren Zeiträume pro Sensor zu unterscheiden und eine klare Vorstellung davon zu bekommen, welche Daten zu verwenden sind.

```{r}
RTH_05Volumen = sapply(1993:2020, function(y) sum(Goerlitz_DWD$RTH_05[which(year(Goerlitz_DWD$MESS_DATUM)==y)], na.rm=T))
print(RTH_05Volumen)
RWH_05Volumen = sapply(1993:2020, function(y) sum(Goerlitz_DWD$RWH_05[which(year(Goerlitz_DWD$MESS_DATUM)==y)], na.rm=T))
print(RWH_05Volumen)
RS_05Volumen  = sapply(1993:2020, function(y) sum(Goerlitz_DWD$RS_05[which(year(Goerlitz_DWD$MESS_DATUM)==y)], na.rm=T))
print(RS_05Volumen)
```

Wie aus der jährlichen Regenmenge erkennbar ist, lassen sich zwei Perioden unterscheiden: die erste Periode, in der der RTH- und RWH-Sensor messen, und die zweite, in der der RS-Sensor misst. Da die jährliche Regenmenge für den RTH-Sensor sehr hoch ist (mehr als 9000 mm), wird die Spalte *RTH_05* für die erste Periode und die Spalte *RS_05* für die zweite Periode verwendet.Außerdem, da im DWD-Datenframe *Goerlitz_DWD* bestimmte Zeitpunkte fehlen, kann der Datenframe *Goerlitz_Daten* nur mit den Zeitpunkten gefüllt werden, die im DWD-Datenframe *Goerlitz_DWD* vorhanden sind.

```{r}
erstePeriode = Goerlitz_DWD[which(is.na(Goerlitz_DWD$RWH_05)==F),]
print(range(erstePeriode$MESS_DATUM))
zweitePeriode = Goerlitz_DWD[which(is.na(Goerlitz_DWD$RS_05)==F),]
print(range(zweitePeriode$MESS_DATUM))
Goerlitz_Daten[which(Goerlitz_Daten$Datum%in%erstePeriode$MESS_DATUM),2]  = erstePeriode$RWH_05[which( erstePeriode$MESS_DATUM %in%Goerlitz_Daten$Datum)]
Goerlitz_Daten[which(Goerlitz_Daten$Datum%in%zweitePeriode$MESS_DATUM),2] = zweitePeriode$RS_05[which( zweitePeriode$MESS_DATUM %in%Goerlitz_Daten$Datum)]
print(head(Goerlitz_Daten))
Sensor_WechselZeit = range(zweitePeriode$MESS_DATUM)[1]
```

Der Datenframe ist vollständig mit Datum und Regenintensitäten in mm pro 5 Minuten. Für fehlende Werte wird der NA-Code verwendet. Der nächste Code prüft für jedes Jahr die jährliche Niederschlagssumme, die maximale Intensität (mm/5min) und die Länge der nicht fehlenden Werte.

```{r}
summary(Goerlitz_Daten$RH[which(Goerlitz_Daten>0)])
jaehrlicheVolum = sapply(1993:2020, function(y) sum(Goerlitz_Daten$RH[which(year(Goerlitz_Daten$Datum)==y)], na.rm=T))
print(jaehrlicheVolum)
jaehrliche.MaxInt = sapply(1993:2020, function(y) max(Goerlitz_Daten$RH[which(year(Goerlitz_Daten$Datum)==y)], na.rm=T))
print(jaehrliche.MaxInt)
jaehrliche.Beobachtungen  = sapply(1993:2020, function(y) length(which(is.na(Goerlitz_Daten$RH[which(year(Goerlitz_Daten$Datum)==y)])==F)))
print(jaehrliche.Beobachtungen)
```

Die extrahierte 5-minütige Regenserie erscheint plausibel und wird daher im nächsten Schritt für die Extremwertanalyse verwendet.


## Extremwertanalyse für Regendauern von 5 Minuten bis 7 Tagen durchführen.

Für die extrahierten 5-Minuten-Niederschlagsreihen in Goerlitz wird eine lokale Extremwertanalyse gemäß den im DWA-A 531 Merkblatt beschriebenen Schritten durchgeführt, die darin bestehen:

1. Berechnung der maximalen jährlichen Niederschlagsintensitäten, die bei bestimmten Regendauern (5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080 Minuten) beobachtet sind.

2. Da die Niederschlagsreihe in 5-Minuten-Blöcken verfügbar sind, wird die jährliche Maximalintensitäten für die Dauern von 5, 10, 15 und 20 Minuten korrigiert.

3. Da die Sensoren in der Station Görlitz ausgewechselt wurden, wird überprüft, ob die jährlichen Maximalreihen der kurzen Dauern (5, 10, 15 und 30 Minuten) eine sprunghafte Instationarität aufweisen, die dem Datum des Sensorwechsels entspricht. Wenn es eine solche sprunghafte Instationarität gibt, wird der Sprung eliminiert.

------------------------------------------------------------------------
**HINWEIS: Dieser Schritt wird hier nur durchgeführt, um ein Beispiel für eine solche Anwendung zu zeigen. Laut DWA-A 531 Merkblatt sollte eine Sprungkorrektur getestet werden, wenn ein Sensor vom analogen zum digitalen Typ gewechselt wurde. In der Görlitzer Station sind alle Sensoren digital, so dass eine Sprungprüfung und -korrektur nicht erforderlich ist. Hier wird dieser Schritt nur gezeigt, um einen vollständigen Arbeitsablauf zu darlegen!**
------------------------------------------------------------------------

4. Anpassung der Generalized Extreme Value (GEV) Verteilung an die erhaltenen jährlichen Maximalintensitäten-Serien für die Station Goerlitz. Die Koutsoyiannis-Methode, wie auf den DWA-A 531 Merkblatt beschrieben, wird zur Normalisierung der Intensitäten über die gegebenen Regendauern verwendet.

5. Berechnung der Jährlichkeit (Wiederkehrintervalle) der beobachteten Regenhöhe and bestimmten Regendauern auf der Grundlage der berechneten Extremwertparameter.

6. Durchführung eines Bootstrapps, um die Unsicherheit der Stichprobe bei der Anpassung der Extremwertparameter an die Station Goerlitz zu berücksichtigen.

### Ableitung der jährlichen maximalen Regenintensitäten aus der 5min-Zeitreihe.

Zunächst werden die maximalen jährlichen Niederschlagsintensitäten bei bestimmten Regendauern (5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080 Minuten) berechnet.

Zu diesem Zweck kann *jaehrliche_maxSerie* verwendet werden. Hier wird eine Trockendauer (*DWDmin*) von 4 Stunden verwendet, um unabhängige Regenereignisse zu trennen, und da die Regendaten ins 5 Minuten Zeitschritte gegeben sind, wird das Intervallargument (*Intervall*) auf 5 gesetzt. Um die Parameter der Extremwertverteilung zu ermitteln, sind die maximalen jährlichen Niederschlagsintensitäten für jede Dauer erforderlich. Aus diesem Grund geben wir *SerieTyp=„INT“* an, um die maximalen Intensitäten als Ausgabe zu erhalten.

```{r}
Goerlitz_maxSerie = jaehrliche_maxSerie(Goerlitz_Daten, Dauern = c(5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080), DSDmin=240, Intervall = 5, SerieTyp = "INT")
print(Goerlitz_maxSerie)
```

Die Variable *Goerlitz_maxSerie* ist eine Tabelle mit der maximalen Intensität (mm/h), die bei verschiedenen Regendauern (in Spalten) und Jahren (in Zeilen) ermittelt wurde.

Anschließend wird eine Korrektur der berechneten jährlichen Serien für Dauern, die kürzer oder gleich 30 Minuten sind, vorgenommen. Zu diesem Zweck kann *Intervallkorrektur* verwendet werden. Da die Regendaten ins 5 Minuten Zeitschritte gegeben sind, wird das Intervallargument (*Intervall*) auf 5 gesetzt.

```{r}
Goerlitz_maxSerie    = Intervallkorrektur(Goerlitz_maxSerie, Intervall = 5)
```

Schließlich wird eine Sprungeliminierung bei Dauern von kürzer als 30 Minuten durchgeführt, falls eine sprunghafte Instationarität in den jährlichen Serien vorhanden ist. Zu diesem Zweck kann *Sprung_Korrektur* verwendet werden. Zusätzlich zur Eingabe der jährlichen Serie (*Goerlitz_maxSerie*) benötigt die Funktion das Datum des Sensorwechsels in einer Variablen vom Typ *Date*.

```{r}
WechselDatum = as.Date(Sensor_WechselZeit)
Goerlitz_maxSerie_korrigiert    = Sprung_Korrektur(Goerlitz_maxSerie, WechselDatum)
# Die Differenz vor und nach der Funktion sprungKorrektur() überprüfen.
print(round(Goerlitz_maxSerie_korrigiert-Goerlitz_maxSerie,0))
```

Wie bereits erwähnt, gibt es keine Sprünge in den Daten, und daher ist die von der Funktion *Sprung_Korrektur* zurückgegebene Tabelle dieselbe wie die Eingabe.

### Schätzung der Parameter, die die Verteilung der Extremwerte über alle Dauern beschreiben

Die Funktion *Parameter_Schaetzung* kann verwendet werden, um die Extremwertparameter aus den erhaltenen jährlichen Maximalintensitätsreihen zu schätzen. In der Funktion sollte die Dauer für die Extremwertparameter angegeben werden, und die Art der Verteilung, die angepasst werden soll. Wie in DWA-A 531 Blatt wird hier die GEV-Verteilung mit einem festen Formparameter von -0,1 verwendet (deshalb lauten die Argumente *methGEV="GEV ‚*, *formTyp=‘FIX “* und *Gamma=-0,1*).

------------------------------------------------------------------------
**HINWEIS: Die Funktion *Parameter_Schaetzung* kann entweder eine GEV- oder eine Gumbel-Verteilung anpassen: Für Gumbel *methGEV="GUM"*, während *formTyp* und *Gamma* in diesem Fall irrelevant sind); für die GEV kann der Formparameter auch aus L-Momenten geschätzt werden (mit *formTyp="CON"*, in diesem Fall ist *Gamma* irrelevant). In allen Fällen werden die maximalen Intensitäten über die gegebene Regendauer normalisiert. Die Funktion *Parameter_Schaetzung()* kann nicht GEV-Verteilungen individuell an jede Dauer anpassen!**
------------------------------------------------------------------------

```{r}
N_pars      = Parameter_Schaetzung(Goerlitz_maxSerie, Dauern = c(5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080), methGEV="GEV", formTyp = "FIX", Gamma = -0.1)
print(N_pars)
```

Die zurückgegebene Variable *N_pars* ist ein einzeiliger Dataframe, der die berechneten Parameter der Extremwertverteilung des Niederschlags an der Station Goerliz enthält: *Mu* - der GEV- Lokationsparameter, *Sigma* - der GEV- Skalenparameter, *Gamma* - der GEV- Formparameter, *Theta* und *Eta* jeweils der erste und zweite Koutsoyiannis- Parameter, während *KW* die Kruskal-Wallis Teststatistik ist, die bei der Optimierung der Parameter erreicht wurde.

### Schätzung der Regenhöhe für angegeben Regendauer und Wiederkehrintervalle

Sobald die Parameter bekannt sind, lässt sich die zu erwartende Regenhöhe bei verschiedenen Dauern und Wiederkehrintervalle an der Station Goerlitz berechnen. Zu diesem Zweck kann die Funktion *hN_Schaetzung* verwendet werden. Neben den Parametern (*N_pars*), den Dauern (*Dauern*) und Wiederkehrintervalle (*Tn*), sollte auch die GEV-Methode (*methGEV*) angegeben werden. In diesem Fall wird der *SerieTyp* auf DDF gesetzt, um Regenhöhe (mm/Dauer) als Output zu erhalten. Außerdem kann die Art der Ausgabe mit dem Argument *SerieTyp* gesteuert werden (*DDF* für Regenhöhe in mm/Dauer oder *IDF* für Regenintensität in mm/h).

```{r}
H_quas      = hN_Schaetzung(N_pars, Dauern = c(5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080),Tn =c(2,5,10,20,50,100), methGEV="GEV",SerieTyp = "DDF")
print(H_quas)
```

Die zurückgegebene Variable *H_quas* ist eine Tabelle (Dataframe-Format) mit den Wiederkehrintervallen in verschiedenen Zeilen und der Regendauer in verschiedenen Spalten. Da in diesem Fall der *SerieTyp=„DDF“* ist, sind die Einheiten in mm/Dauer.

### Schätzung der Unsicherheitsbereiche auf der Grundlage von Stichproben-Bootstrapping

Die geschätzten jährlichen Maximalintensitätsserien können *nBoots*-mal mit Ersatz neu gesampelt werden, um die Stichprobenunsicherheit zu berücksichtigen. Anschließend können für jede *nBoots*-Realisierung die Parameter geschätzt werden. Auf diese Weise erhält man *nBoots* Realisierungen der Parameter, die als Grundlage für die Berechnung von Konfidenzintervallen nicht nur der Parameter, sondern auch der Quantila verwendet werden können. 
Zu diesem Zweck kann die Funktion *Unsicherheit_Schaetzung* implementiert werden. Neben den bisher angegebenen typischen Informationen zur Berechnung von Parametern und Extremwerten können drei weitere Argumente festgelegt werden: *nBoots* - zur Angabe der gewünschten Anzahl von Realisierungen, *rSeed* - eine Zufallszahl, um sicherzustellen, dass die Ausgabe wiederholbar ist, und *Konfidenzgrenzen* - zur Angabe der Quantils der oberen und unteren Konfidenzintervallgrenzen. 
**Hinweis: Dies kann mehrere Minuten dauern!**

```{r}
KI          = Unsicherheit_Schaetzung(Goerlitz_maxSerie,
                                  Tn =c(2,5,10,20,50,100),
                                  Dauern = c(5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080),
                                  methGEV="GEV",
                                  formTyp = "FIX",
                                  Gamma=-0.1,
                                  nBoots = 100,
                                  rSeed = 1232,
                                  SerieTyp = "DDF",
                                  Konfidenzgrenzen  = c(0.025,0.975))
# Zugriff auf die Parameterinformationen
PAR_KI      = KI$PAR_INFO
# Zugriff auf die Quantils Informationen 
HN_KI       = KI$QUA_INFO
```

Die Funktion *Unsicherheit_Schaetzung* gibt eine Liste mit den Parameterinformationen *PAR_INFO* und Quantils Informationen *QUA_INFO* zurück. Die beiden Einträge in der Liste enthalten Informationen über die angegebenen Quantile für die Berechnung der Grenzen des Konfidenzintervalls, des Mittelwerts der Realisierungen und der relativen Unsicherheit *(Ko-Ku)/K*. 

### Darstellung der lokal geschätzten Regenhöhen unter Berücksichtigung des Unsicherheitsbereichs

Der folgende Code zeigt ein Beispiel für die Visualisierung verschiedener Regenhöhen an der Station Goerlitz, die mit verschiedenen Regendauern (auf der x-Achse) und Wiederkehrintervallen (in verschiedenen Farben) einhergehen. Für beide Achsen wird eine logarithmische Darstellung verwendet. 

```{r, echo=TRUE, eval=TRUE, include=TRUE}
RegenDauern = c(5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080)
Tn_Farbe    = rev(hcl.colors(6, palette = "viridis"))
plot(RegenDauern, H_quas["2",], type="l", lwd=2, lty=1, log="xy", col=Tn_Farbe[1], ylab="hN [mm]", ylim=range(H_quas), xlab="Dauer [min]", main = "Station 01684")
lines(RegenDauern, H_quas["5",],  lwd=2, col=Tn_Farbe[2])
lines(RegenDauern, H_quas["10",], lwd=2, col=Tn_Farbe[3])
lines(RegenDauern, H_quas["20",], lwd=2, col=Tn_Farbe[4])
lines(RegenDauern, H_quas["50",], lwd=2, col=Tn_Farbe[5])
lines(RegenDauern, H_quas["100",],lwd=2, col=Tn_Farbe[6])
legend("bottomright", legend = c(2,5,10,20,50,100),lty=1, lwd=3, col=Tn_Farbe, cex=0.8, title="Tn", horiz=T, bty="n")
```

Im folgenden Beispiel wird ein Code-Teil zur Darstellung des 100-jährlichen Regenvolumens für die Station Görlitz gegeben, wie es für die Dauer von 5 Minuten bis 7 Tagen aus der bisher durchgeführten Extremwertanalyse der 5-Minuten- Regenfalldaten des DWD berechnet wurde (in rot dargestellt). Die Konfidenzgrenze, die den 2.5 %- und 97.5 %-Quantils der 100 Realisierungen für die 100-jährliche Regenmenge entsprechen, sind ebenfalls in blau dargestellt.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
RegenDauern = c(5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080)
plot(RegenDauern, H_quas["100",], type="l", lwd=2, lty=2, log="xy", ylim=range(HN_KI$`97.5%`["100",], HN_KI$`2.5%`["100",]), col="red",
     ylab="hN [mm]", xlab="Dauer [min]", main = "Station 01684")
polygon(c(RegenDauern, rev(RegenDauern)), c(HN_KI$`2.5%`["100",], rev(HN_KI$`97.5%`["100",])), col="royalblue", border=NA)
lines(RegenDauern, HN_KI$Mittelwert["100",], type="l", col="royalblue4", lwd=2)
lines(RegenDauern, H_quas["100",], type="l", col="red", lwd=2, lty=2)
legend("topleft", c("95%KI", "Mittelwert", "lokale Schätzung"),  col=c("royalblue", "royalblue4", "red"), lty=c(1, 1, 2), lwd=c(10,2,2), title = "Legende", bty="n")
```

Der folgende Code zeigt drei verschiedene Beispiele für die Visualisierung der berechneten relativen Unsicherheiten (Ko-Ku/K) aus dem *nBoots* Bootstrapping als eine Möglichkeit, die Unsicherheit zu messen.Die Einheiten sind in Prozent ausgegeben.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
KI = round(HN_KI$rel.Unsicherheit,2)
# Option 1 
barplot(as.matrix(KI), col=Tn_Farbe, ylab="KI [%]",  xlab="Dauer [min]", main = "Station 01684")
legend("top", legend = c(2,5,10,20,50,100), fill=Tn_Farbe, cex=0.8, title="Tn", horiz=T, bty="n")
# Option 2 
barplot(as.matrix(KI),col=Tn_Farbe, beside=T, ylim=c(0,50), ylab="KI [%]", xlab="Dauer [min]", main = "Station 01684")
legend("top", legend = c(2,5,10,20,50,100), fill=Tn_Farbe, cex=0.8, title="Tn", horiz=T, bty="n")
# Option 3 
Dauer_Farbe = hcl.colors(dim(KI)[2], "blues", rev = T)
barplot(as.matrix(t(KI)),col=Dauer_Farbe, beside=T, ylim=c(0,60), ylab="KI [%]", xlab="Tn", main = "Station 01684")
legend("top", legend = RegenDauern, fill=Dauer_Farbe, cex=0.8, title="Dauer (min)",  bty="n", ncol=6)

```

### Schätzung der Wiederkehrintervalle auf der Grundlage der beobachteten Werte eines Regenereignisses

Möglicherweise ist es auch erwünscht, dass nach der Beobachtung eines Regenereignisses die Jährlichkeit bei verschiedenen Dauern erfasst werden kann. Zu diesem Zweck kann die Funktion *Tn_Schaetzung* verwendet werden. Die Parameter *N_pars*, die die Extremwertstatistik beschreiben, sollten als einzeiliger Dataframe angegeben (Benennung der Spalten ist wichtig!), die beobachtete Regenmenge *hN* in mm sollten bei verschiedenen Regendauern *Dauern* als Vektor angegeben. Es ist wichtig, dass die Länge der Vektoren *hN* und *Dauern* übereinstimmen! Außerdem sollte es in der Funktion angegeben ob die Gumbel- oder GEV-Parameter in N_pars verwendet sind. 

```{r, echo=TRUE, eval=TRUE, include=TRUE}
Hn_Tn        = Tn_Schaetzung(N_pars,Dauern = c(5, 10, 60), 
                            hN   = c(15, 20, 30),
                            methGEV="GEV")
print(Hn_Tn)

```

Die Funktion *Tn_Schaetzung* liefert eine Tabelle mit der beobachteten Regenhöhe (mm), der Regendauer (min) und der geschätzten Wiederkehrintervalle (Tn).

## Umgang mit den Kostra-DWD-2020 Schätzungen
Für einen bestimmten Ort ist es auch möglich, die örtlich geschätzte Statistik oder den Extremniederschlag mit der Kostra-DWD-2020 zu vergleichen. In den folgenden Beispielen wird gezeigt, wie die Informationen über Extremniederschläge aus den Kostra-DWD-2020-Daten extrahiert und mit den bisher berechneten Informationen verglichen werden können. 

------------------------------------------------------------------------
**Hinweis: Das Beispiel wird hier nur für eine Station - Görlitz - gezeigt. Es ist jedoch möglich, mehrere Stationen auf einmal zu berechnen. Weitere Informationen finden Sie in der Funktion *help(Kostra2020_hN_Schaetzung)* oder *help(Kostra2020_Parameter)*.**
------------------------------------------------------------------------

Die Funktion *Kostra2020_hN_Schaetzung* liest für bestimmte Standortkoordinaten, Dauer und Wiederkehrintervalle die entsprechende extreme Regenhöhe (*hN*) und den Unsicherheitsbereich (wenn Argument *Unsicherheit=T*). Das folgende Beispiel liest die KOSTRA-DWD-2020 Regenhöhe für Goerlitz und die angegebenen Dauern und Wiederkehrintervalle.

```{r}
Tn = c(2,5,10,20,50,100)
Dauern = c(5, 10, 15, 30, 60, 120, 360, 720, 1440, 2880, 4320, 10080)
Station = data.frame(Stations_id = 01684, geoBreite = 51.1621, geoLaenge = 14.9506)
H_quas_Kostra = Kostra2020_hN_Schaetzung(Standorte = Station, Dauern=Dauern, Tn =Tn, Temp_Pfad = "./", Unsicherheit=T)
# Zugang zu den Regenhöhen und formatiert sie so, dass sie der zuvor geschätzten Tabelle H_quas entsprechen. 
Hn_Kostra = H_quas_Kostra$Kostra_HN
print(Hn_Kostra)
Hn_Kostra = matrix(unlist(Hn_Kostra[1,-(1:3)]), nrow = 6, ncol = 12, byrow=F) 
Hn_Kostra = as.data.frame(Hn_Kostra)
rownames(Hn_Kostra) = Tn
names(Hn_Kostra) = Dauern

# Zugang zu den Unsicherheiten und formatiert sie so, dass sie der zuvor geschätzten Tabelle H_quas entsprechen. 
UC_Kostra = H_quas_Kostra$Kostra_UC
print(UC_Kostra)
UC_Kostra = matrix(unlist(UC_Kostra[1,-(1:3)]), nrow = 6, ncol = 12, byrow=F) 
UC_Kostra = as.data.frame(UC_Kostra)
rownames(UC_Kostra) = Tn
names(UC_Kostra) = Dauern

# Da die Kostra-DWD-2020 Unsicherheiten in Prozent angegeben sind, kann die obere und untere Konfidenzgrenze wie folgt berechnet werden:
Hn_Kostra_Ku =  Hn_Kostra - round(UC_Kostra*Hn_Kostra/100,2) # untere Grenze
Hn_Kostra_Ko =  Hn_Kostra + round(UC_Kostra*Hn_Kostra/100,2) # obere Grenze
```

Das folgende Beispiel zeigt einen Codeausschnitt zur Darstellung der 100-jährlichen Regenhöhen für die Station Görlitz, wie es für die Dauern von 5 Minuten bis 7 Tagen aus der bisher durchgeführten Extremwertanalyse der 5-Minuten-Niederschlagsdaten des DWD (rot dargestellt) und Kostra-DWD-2020 (schwarz dargestellt) berechnet wurde. Die 95% Konfidenzgrenzen von Kostra-DWD-2020 und der lokalen Analyse sind ebenfalls grau bzw. blau dargestellt.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
RegenDauern = c(5, 10, 15,30,60,120,360,720,1440, 2880, 4320, 10080)
plot(RegenDauern, H_quas["100",], type="l", lwd=2, lty=2, log="xy", ylim=range(HN_KI$`97.5%`["100",], HN_KI$`2.5%`["100",], Hn_Kostra_Ku["100",], Hn_Kostra_Ko["100",]), col="red",
     ylab="hN [mm]", xlab="Dauer [min]", main = "Station 01684, Tn=100")
polygon(c(RegenDauern, rev(RegenDauern)), c(Hn_Kostra_Ku["100",], rev(Hn_Kostra_Ko["100",])), col="lightgrey", border=NA)
polygon(c(RegenDauern, rev(RegenDauern)), c(HN_KI$`2.5%`["100",], rev(HN_KI$`97.5%`["100",])), col="royalblue", border=NA)
lines(RegenDauern, HN_KI$Mittelwert["100",], type="l", col="royalblue4", lwd=2)
lines(RegenDauern, H_quas["100",], type="l", col="red", lwd=2, lty=2)
lines(RegenDauern, Hn_Kostra["100",], type="l", col="black", lwd=2, lty=2)

legend("topleft", c("lokale - 95%KI", "lokale Mittelwert", "lokale Hn", "Unsicherheitbereich Kostra-DWD-2020",  "Kostra-DWD-2020"),  col=c("royalblue", "royalblue4", "red", "lightgrey", "black"), lty=c(1, 1, 2, 1, 2), lwd=c(10,2,2, 10, 2), title = "Legende", bty="n")
```

Das folgende Beispiel zeigt einen Codeausschnitt zur Darstellung der Regenhöhen mit D=60min für die Station Görlitz, wie es für die Wiederkehrintervalle von 2 bis 100 Jahren aus der bisher durchgeführten Extremwertanalyse der 5-Minuten-Niederschlagsdaten des DWD (rot dargestellt) und Kostra-DWD-2020 (schwarz dargestellt) berechnet wurde. Die 95% Konfidenzgrenzen von Kostra-DWD-2020 und der lokalen Analyse sind ebenfalls grau bzw. blau dargestellt.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
plot(Tn, H_quas[,"60"], type="l", lwd=2, lty=2, log="x", ylim=range(15, 70), col="red",
     ylab="hN [mm]", xlab="Tn", main = "Station 01684, D=60min")
polygon(c(Tn, rev(Tn)), c(Hn_Kostra_Ku[,"60"], rev(Hn_Kostra_Ko[,"60"])), col="lightgrey", border=NA)
polygon(c(Tn, rev(Tn)), c(HN_KI$`2.5%`[,"60"], rev(HN_KI$`97.5%`[,"60"])), col="royalblue", border=NA)
lines(Tn, HN_KI$Mittelwert[,"60"], type="l", col="royalblue4", lwd=2)
lines(Tn, H_quas[,"60"], type="l", col="red", lwd=2, lty=2)
lines(Tn, Hn_Kostra[,"60"], type="l", col="black", lwd=2, lty=2)
legend("topleft", c("lokale - 95%KI", "lokale Mittelwert", "lokale Hn", "Unsicherheitbereich Kostra-DWD-2020",  "Kostra-DWD-2020"),  col=c("royalblue", "royalblue4", "red", "lightgrey", "black"), lty=c(1, 1, 2, 1, 2), lwd=c(10,2,2, 10, 2), title = "Legende", bty="n")
```

Die Funktion *Kostra2020_Parameter* liest für bestimmte Standortkoordinaten die entsprechende Parameter von Kostra-DWD-2020. Das folgende Beispiel liest die  KOSTRA-DWD-2020 Parameter für Goerlitz. Dann wird die *Tn_Schaetzung* Funktion verwendet um die Jährlichkeit der beobachtete Regenmenge *hN* bei verschiedenen Regendauern *Dauern* zu schätzen.

```{r, echo=TRUE, eval=TRUE, include=TRUE}
kostraParameter    = Kostra2020_Parameter(Standorte = Station )
Hn_Tn_Kostra       = Tn_Schaetzung(kostraParameter, Dauern = c(5, 10, 60), 
                            hN   = c(15, 20, 30), # values have to be in mm
                            methGEV="GEV")
print(Hn_Tn_Kostra)

```

